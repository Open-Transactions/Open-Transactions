# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package otapi;
use base qw(Exporter);
use base qw(DynaLoader);
package otapic;
bootstrap otapi;
package otapi;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package otapi;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package otapi;

*imaxabs = *otapic::imaxabs;
*imaxdiv = *otapic::imaxdiv;
*OT_CLI_GetArgsCount = *otapic::OT_CLI_GetArgsCount;
*OT_CLI_GetValueByKey = *otapic::OT_CLI_GetValueByKey;
*OT_CLI_GetValueByIndex = *otapic::OT_CLI_GetValueByIndex;
*OT_CLI_GetKeyByIndex = *otapic::OT_CLI_GetKeyByIndex;
*OT_CLI_ReadLine = *otapic::OT_CLI_ReadLine;
*OT_CLI_ReadUntilEOF = *otapic::OT_CLI_ReadUntilEOF;
*InitDefaultStorage = *otapic::InitDefaultStorage;
*GetDefaultStorage = *otapic::GetDefaultStorage;
*CreateStorageContext = *otapic::CreateStorageContext;
*CreateObject = *otapic::CreateObject;
*CheckStringsExistInOrder = *otapic::CheckStringsExistInOrder;
*Exists = *otapic::Exists;
*FormPathString = *otapic::FormPathString;
*StoreString = *otapic::StoreString;
*QueryString = *otapic::QueryString;
*StorePlainString = *otapic::StorePlainString;
*QueryPlainString = *otapic::QueryPlainString;
*StoreObject = *otapic::StoreObject;
*QueryObject = *otapic::QueryObject;
*EncodeObject = *otapic::EncodeObject;
*DecodeObject = *otapic::DecodeObject;
*EraseValueByKey = *otapic::EraseValueByKey;
*OTRecord_GetTypeString = *otapic::OTRecord_GetTypeString;
*OT_API_Set_AddrBookCallback = *otapic::OT_API_Set_AddrBookCallback;
*OT_API_Set_PasswordCallback = *otapic::OT_API_Set_PasswordCallback;

############# Class : otapi::imaxdiv_t ##############

package otapi::imaxdiv_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
*swig_quot_get = *otapic::imaxdiv_t_quot_get;
*swig_quot_set = *otapic::imaxdiv_t_quot_set;
*swig_rem_get = *otapic::imaxdiv_t_rem_get;
*swig_rem_set = *otapic::imaxdiv_t_rem_set;
sub new {
    my $pkg = shift;
    my $self = otapic::new_imaxdiv_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_imaxdiv_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::VectorUnsignedChar ##############

package otapi::VectorUnsignedChar;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = otapic::new_VectorUnsignedChar(@_);
    bless $self, $pkg if defined($self);
}

*size = *otapic::VectorUnsignedChar_size;
*empty = *otapic::VectorUnsignedChar_empty;
*clear = *otapic::VectorUnsignedChar_clear;
*push = *otapic::VectorUnsignedChar_push;
*pop = *otapic::VectorUnsignedChar_pop;
*get = *otapic::VectorUnsignedChar_get;
*set = *otapic::VectorUnsignedChar_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_VectorUnsignedChar($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::MapStringString ##############

package otapi::MapStringString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = otapic::new_MapStringString(@_);
    bless $self, $pkg if defined($self);
}

*size = *otapic::MapStringString_size;
*empty = *otapic::MapStringString_empty;
*clear = *otapic::MapStringString_clear;
*get = *otapic::MapStringString_get;
*set = *otapic::MapStringString_set;
*del = *otapic::MapStringString_del;
*has_key = *otapic::MapStringString_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_MapStringString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OTPassword ##############

package otapi::OTPassword;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
*DEFAULT_SIZE = *otapic::OTPassword_DEFAULT_SIZE;
*LARGER_SIZE = *otapic::OTPassword_LARGER_SIZE;
*swig_m_theBlockSize_get = *otapic::OTPassword_m_theBlockSize_get;
*swig_m_theBlockSize_set = *otapic::OTPassword_m_theBlockSize_set;
*isPassword = *otapic::OTPassword_isPassword;
*getPassword_uint8 = *otapic::OTPassword_getPassword_uint8;
*getPassword = *otapic::OTPassword_getPassword;
*getPasswordWritable = *otapic::OTPassword_getPasswordWritable;
*getPasswordWritable_char = *otapic::OTPassword_getPasswordWritable_char;
*setPassword = *otapic::OTPassword_setPassword;
*setPassword_uint8 = *otapic::OTPassword_setPassword_uint8;
*addChar = *otapic::OTPassword_addChar;
*randomizePassword_uint8 = *otapic::OTPassword_randomizePassword_uint8;
*randomizePassword = *otapic::OTPassword_randomizePassword;
*isMemory = *otapic::OTPassword_isMemory;
*getMemory = *otapic::OTPassword_getMemory;
*getMemory_uint8 = *otapic::OTPassword_getMemory_uint8;
*getMemoryWritable = *otapic::OTPassword_getMemoryWritable;
*setMemory = *otapic::OTPassword_setMemory;
*addMemory = *otapic::OTPassword_addMemory;
*randomizeMemory_uint8 = *otapic::OTPassword_randomizeMemory_uint8;
*randomizeMemory = *otapic::OTPassword_randomizeMemory;
*getBlockSize = *otapic::OTPassword_getBlockSize;
*Compare = *otapic::OTPassword_Compare;
*getPasswordSize = *otapic::OTPassword_getPasswordSize;
*getMemorySize = *otapic::OTPassword_getMemorySize;
*zeroMemory = *otapic::OTPassword_zeroMemory;
*safe_memcpy = *otapic::OTPassword_safe_memcpy;
*CreateTextBuffer = *otapic::OTPassword_CreateTextBuffer;
*SetSize = *otapic::OTPassword_SetSize;
sub new {
    my $pkg = shift;
    my $self = otapic::new_OTPassword(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OTPassword($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OTAPI_Wrap ##############

package otapi::OTAPI_Wrap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
*SetExecutor = *otapic::OTAPI_Wrap_SetExecutor;
*Exec = *otapic::OTAPI_Wrap_Exec;
*It = *otapic::OTAPI_Wrap_It;
*OTAPI = *otapic::OTAPI_Wrap_OTAPI;
*StringToLong = *otapic::OTAPI_Wrap_StringToLong;
*LongToString = *otapic::OTAPI_Wrap_LongToString;
*StringToUlong = *otapic::OTAPI_Wrap_StringToUlong;
*UlongToString = *otapic::OTAPI_Wrap_UlongToString;
*AppInit = *otapic::OTAPI_Wrap_AppInit;
*AppCleanup = *otapic::OTAPI_Wrap_AppCleanup;
*SetAppBinaryFolder = *otapic::OTAPI_Wrap_SetAppBinaryFolder;
*SetHomeFolder = *otapic::OTAPI_Wrap_SetHomeFolder;
*SetWallet = *otapic::OTAPI_Wrap_SetWallet;
*WalletExists = *otapic::OTAPI_Wrap_WalletExists;
*LoadWallet = *otapic::OTAPI_Wrap_LoadWallet;
*SwitchWallet = *otapic::OTAPI_Wrap_SwitchWallet;
*Output = *otapic::OTAPI_Wrap_Output;
*GetTime = *otapic::OTAPI_Wrap_GetTime;
*NumList_Add = *otapic::OTAPI_Wrap_NumList_Add;
*NumList_Remove = *otapic::OTAPI_Wrap_NumList_Remove;
*NumList_VerifyQuery = *otapic::OTAPI_Wrap_NumList_VerifyQuery;
*NumList_VerifyAll = *otapic::OTAPI_Wrap_NumList_VerifyAll;
*NumList_Count = *otapic::OTAPI_Wrap_NumList_Count;
*Encode = *otapic::OTAPI_Wrap_Encode;
*Decode = *otapic::OTAPI_Wrap_Decode;
*Encrypt = *otapic::OTAPI_Wrap_Encrypt;
*Decrypt = *otapic::OTAPI_Wrap_Decrypt;
*CreateSymmetricKey = *otapic::OTAPI_Wrap_CreateSymmetricKey;
*SymmetricEncrypt = *otapic::OTAPI_Wrap_SymmetricEncrypt;
*SymmetricDecrypt = *otapic::OTAPI_Wrap_SymmetricDecrypt;
*SignContract = *otapic::OTAPI_Wrap_SignContract;
*FlatSign = *otapic::OTAPI_Wrap_FlatSign;
*AddSignature = *otapic::OTAPI_Wrap_AddSignature;
*VerifySignature = *otapic::OTAPI_Wrap_VerifySignature;
*VerifyAndRetrieveXMLContents = *otapic::OTAPI_Wrap_VerifyAndRetrieveXMLContents;
*GetMemlogSize = *otapic::OTAPI_Wrap_GetMemlogSize;
*GetMemlogAtIndex = *otapic::OTAPI_Wrap_GetMemlogAtIndex;
*PeekMemlogFront = *otapic::OTAPI_Wrap_PeekMemlogFront;
*PeekMemlogBack = *otapic::OTAPI_Wrap_PeekMemlogBack;
*PopMemlogFront = *otapic::OTAPI_Wrap_PopMemlogFront;
*PopMemlogBack = *otapic::OTAPI_Wrap_PopMemlogBack;
*CreateNym = *otapic::OTAPI_Wrap_CreateNym;
*GetNym_ActiveCronItemIDs = *otapic::OTAPI_Wrap_GetNym_ActiveCronItemIDs;
*GetActiveCronItem = *otapic::OTAPI_Wrap_GetActiveCronItem;
*GetNym_SourceForID = *otapic::OTAPI_Wrap_GetNym_SourceForID;
*GetNym_AltSourceLocation = *otapic::OTAPI_Wrap_GetNym_AltSourceLocation;
*GetNym_CredentialCount = *otapic::OTAPI_Wrap_GetNym_CredentialCount;
*GetNym_CredentialID = *otapic::OTAPI_Wrap_GetNym_CredentialID;
*GetNym_CredentialContents = *otapic::OTAPI_Wrap_GetNym_CredentialContents;
*GetNym_RevokedCredCount = *otapic::OTAPI_Wrap_GetNym_RevokedCredCount;
*GetNym_RevokedCredID = *otapic::OTAPI_Wrap_GetNym_RevokedCredID;
*GetNym_RevokedCredContents = *otapic::OTAPI_Wrap_GetNym_RevokedCredContents;
*GetNym_SubcredentialCount = *otapic::OTAPI_Wrap_GetNym_SubcredentialCount;
*GetNym_SubCredentialID = *otapic::OTAPI_Wrap_GetNym_SubCredentialID;
*GetNym_SubCredentialContents = *otapic::OTAPI_Wrap_GetNym_SubCredentialContents;
*AddSubcredential = *otapic::OTAPI_Wrap_AddSubcredential;
*RevokeSubcredential = *otapic::OTAPI_Wrap_RevokeSubcredential;
*CreateServerContract = *otapic::OTAPI_Wrap_CreateServerContract;
*CreateAssetContract = *otapic::OTAPI_Wrap_CreateAssetContract;
*CalculateAssetContractID = *otapic::OTAPI_Wrap_CalculateAssetContractID;
*CalculateServerContractID = *otapic::OTAPI_Wrap_CalculateServerContractID;
*AddServerContract = *otapic::OTAPI_Wrap_AddServerContract;
*AddAssetContract = *otapic::OTAPI_Wrap_AddAssetContract;
*GetServerCount = *otapic::OTAPI_Wrap_GetServerCount;
*GetAssetTypeCount = *otapic::OTAPI_Wrap_GetAssetTypeCount;
*GetAccountCount = *otapic::OTAPI_Wrap_GetAccountCount;
*GetNymCount = *otapic::OTAPI_Wrap_GetNymCount;
*GetServer_ID = *otapic::OTAPI_Wrap_GetServer_ID;
*GetServer_Name = *otapic::OTAPI_Wrap_GetServer_Name;
*GetServer_Contract = *otapic::OTAPI_Wrap_GetServer_Contract;
*FormatAmount = *otapic::OTAPI_Wrap_FormatAmount;
*StringToAmount = *otapic::OTAPI_Wrap_StringToAmount;
*GetAssetType_ID = *otapic::OTAPI_Wrap_GetAssetType_ID;
*GetAssetType_Name = *otapic::OTAPI_Wrap_GetAssetType_Name;
*GetAssetType_TLA = *otapic::OTAPI_Wrap_GetAssetType_TLA;
*GetAssetType_Contract = *otapic::OTAPI_Wrap_GetAssetType_Contract;
*GetAccountWallet_ID = *otapic::OTAPI_Wrap_GetAccountWallet_ID;
*GetAccountWallet_Name = *otapic::OTAPI_Wrap_GetAccountWallet_Name;
*GetAccountWallet_Balance = *otapic::OTAPI_Wrap_GetAccountWallet_Balance;
*GetAccountWallet_Type = *otapic::OTAPI_Wrap_GetAccountWallet_Type;
*GetAccountWallet_AssetTypeID = *otapic::OTAPI_Wrap_GetAccountWallet_AssetTypeID;
*GetAccountWallet_ServerID = *otapic::OTAPI_Wrap_GetAccountWallet_ServerID;
*GetAccountWallet_NymID = *otapic::OTAPI_Wrap_GetAccountWallet_NymID;
*GetAccountWallet_InboxHash = *otapic::OTAPI_Wrap_GetAccountWallet_InboxHash;
*GetAccountWallet_OutboxHash = *otapic::OTAPI_Wrap_GetAccountWallet_OutboxHash;
*VerifyAccountReceipt = *otapic::OTAPI_Wrap_VerifyAccountReceipt;
*GetNym_TransactionNumCount = *otapic::OTAPI_Wrap_GetNym_TransactionNumCount;
*GetNym_ID = *otapic::OTAPI_Wrap_GetNym_ID;
*GetNym_Name = *otapic::OTAPI_Wrap_GetNym_Name;
*GetNym_Stats = *otapic::OTAPI_Wrap_GetNym_Stats;
*GetNym_NymboxHash = *otapic::OTAPI_Wrap_GetNym_NymboxHash;
*GetNym_RecentHash = *otapic::OTAPI_Wrap_GetNym_RecentHash;
*GetNym_InboxHash = *otapic::OTAPI_Wrap_GetNym_InboxHash;
*GetNym_OutboxHash = *otapic::OTAPI_Wrap_GetNym_OutboxHash;
*IsNym_RegisteredAtServer = *otapic::OTAPI_Wrap_IsNym_RegisteredAtServer;
*GetNym_MailCount = *otapic::OTAPI_Wrap_GetNym_MailCount;
*GetNym_MailContentsByIndex = *otapic::OTAPI_Wrap_GetNym_MailContentsByIndex;
*GetNym_MailSenderIDByIndex = *otapic::OTAPI_Wrap_GetNym_MailSenderIDByIndex;
*GetNym_MailServerIDByIndex = *otapic::OTAPI_Wrap_GetNym_MailServerIDByIndex;
*Nym_RemoveMailByIndex = *otapic::OTAPI_Wrap_Nym_RemoveMailByIndex;
*Nym_VerifyMailByIndex = *otapic::OTAPI_Wrap_Nym_VerifyMailByIndex;
*GetNym_OutmailCount = *otapic::OTAPI_Wrap_GetNym_OutmailCount;
*GetNym_OutmailContentsByIndex = *otapic::OTAPI_Wrap_GetNym_OutmailContentsByIndex;
*GetNym_OutmailRecipientIDByIndex = *otapic::OTAPI_Wrap_GetNym_OutmailRecipientIDByIndex;
*GetNym_OutmailServerIDByIndex = *otapic::OTAPI_Wrap_GetNym_OutmailServerIDByIndex;
*Nym_RemoveOutmailByIndex = *otapic::OTAPI_Wrap_Nym_RemoveOutmailByIndex;
*Nym_VerifyOutmailByIndex = *otapic::OTAPI_Wrap_Nym_VerifyOutmailByIndex;
*GetNym_OutpaymentsCount = *otapic::OTAPI_Wrap_GetNym_OutpaymentsCount;
*GetNym_OutpaymentsContentsByIndex = *otapic::OTAPI_Wrap_GetNym_OutpaymentsContentsByIndex;
*GetNym_OutpaymentsRecipientIDByIndex = *otapic::OTAPI_Wrap_GetNym_OutpaymentsRecipientIDByIndex;
*GetNym_OutpaymentsServerIDByIndex = *otapic::OTAPI_Wrap_GetNym_OutpaymentsServerIDByIndex;
*Nym_RemoveOutpaymentsByIndex = *otapic::OTAPI_Wrap_Nym_RemoveOutpaymentsByIndex;
*Nym_VerifyOutpaymentsByIndex = *otapic::OTAPI_Wrap_Nym_VerifyOutpaymentsByIndex;
*Wallet_CanRemoveServer = *otapic::OTAPI_Wrap_Wallet_CanRemoveServer;
*Wallet_RemoveServer = *otapic::OTAPI_Wrap_Wallet_RemoveServer;
*Wallet_CanRemoveAssetType = *otapic::OTAPI_Wrap_Wallet_CanRemoveAssetType;
*Wallet_RemoveAssetType = *otapic::OTAPI_Wrap_Wallet_RemoveAssetType;
*Wallet_CanRemoveNym = *otapic::OTAPI_Wrap_Wallet_CanRemoveNym;
*Wallet_RemoveNym = *otapic::OTAPI_Wrap_Wallet_RemoveNym;
*Wallet_CanRemoveAccount = *otapic::OTAPI_Wrap_Wallet_CanRemoveAccount;
*Wallet_ChangePassphrase = *otapic::OTAPI_Wrap_Wallet_ChangePassphrase;
*Wallet_ExportNym = *otapic::OTAPI_Wrap_Wallet_ExportNym;
*Wallet_ImportNym = *otapic::OTAPI_Wrap_Wallet_ImportNym;
*Wallet_ImportCert = *otapic::OTAPI_Wrap_Wallet_ImportCert;
*Wallet_ExportCert = *otapic::OTAPI_Wrap_Wallet_ExportCert;
*Wallet_GetNymIDFromPartial = *otapic::OTAPI_Wrap_Wallet_GetNymIDFromPartial;
*Wallet_GetServerIDFromPartial = *otapic::OTAPI_Wrap_Wallet_GetServerIDFromPartial;
*Wallet_GetAssetIDFromPartial = *otapic::OTAPI_Wrap_Wallet_GetAssetIDFromPartial;
*Wallet_GetAccountIDFromPartial = *otapic::OTAPI_Wrap_Wallet_GetAccountIDFromPartial;
*SetNym_Name = *otapic::OTAPI_Wrap_SetNym_Name;
*SetAccountWallet_Name = *otapic::OTAPI_Wrap_SetAccountWallet_Name;
*SetAssetType_Name = *otapic::OTAPI_Wrap_SetAssetType_Name;
*SetServer_Name = *otapic::OTAPI_Wrap_SetServer_Name;
*WriteCheque = *otapic::OTAPI_Wrap_WriteCheque;
*DiscardCheque = *otapic::OTAPI_Wrap_DiscardCheque;
*ProposePaymentPlan = *otapic::OTAPI_Wrap_ProposePaymentPlan;
*EasyProposePlan = *otapic::OTAPI_Wrap_EasyProposePlan;
*ConfirmPaymentPlan = *otapic::OTAPI_Wrap_ConfirmPaymentPlan;
*Create_SmartContract = *otapic::OTAPI_Wrap_Create_SmartContract;
*SmartContract_AddBylaw = *otapic::OTAPI_Wrap_SmartContract_AddBylaw;
*SmartContract_AddClause = *otapic::OTAPI_Wrap_SmartContract_AddClause;
*SmartContract_AddVariable = *otapic::OTAPI_Wrap_SmartContract_AddVariable;
*SmartContract_AddCallback = *otapic::OTAPI_Wrap_SmartContract_AddCallback;
*SmartContract_AddHook = *otapic::OTAPI_Wrap_SmartContract_AddHook;
*SmartContract_AddParty = *otapic::OTAPI_Wrap_SmartContract_AddParty;
*SmartContract_AddAccount = *otapic::OTAPI_Wrap_SmartContract_AddAccount;
*SmartContract_CountNumsNeeded = *otapic::OTAPI_Wrap_SmartContract_CountNumsNeeded;
*SmartContract_ConfirmAccount = *otapic::OTAPI_Wrap_SmartContract_ConfirmAccount;
*SmartContract_ConfirmParty = *otapic::OTAPI_Wrap_SmartContract_ConfirmParty;
*Smart_AreAllPartiesConfirmed = *otapic::OTAPI_Wrap_Smart_AreAllPartiesConfirmed;
*Smart_GetBylawCount = *otapic::OTAPI_Wrap_Smart_GetBylawCount;
*Smart_GetBylawByIndex = *otapic::OTAPI_Wrap_Smart_GetBylawByIndex;
*Bylaw_GetLanguage = *otapic::OTAPI_Wrap_Bylaw_GetLanguage;
*Bylaw_GetClauseCount = *otapic::OTAPI_Wrap_Bylaw_GetClauseCount;
*Clause_GetNameByIndex = *otapic::OTAPI_Wrap_Clause_GetNameByIndex;
*Clause_GetContents = *otapic::OTAPI_Wrap_Clause_GetContents;
*Bylaw_GetVariableCount = *otapic::OTAPI_Wrap_Bylaw_GetVariableCount;
*Variable_GetNameByIndex = *otapic::OTAPI_Wrap_Variable_GetNameByIndex;
*Variable_GetType = *otapic::OTAPI_Wrap_Variable_GetType;
*Variable_GetAccess = *otapic::OTAPI_Wrap_Variable_GetAccess;
*Variable_GetContents = *otapic::OTAPI_Wrap_Variable_GetContents;
*Bylaw_GetHookCount = *otapic::OTAPI_Wrap_Bylaw_GetHookCount;
*Hook_GetNameByIndex = *otapic::OTAPI_Wrap_Hook_GetNameByIndex;
*Hook_GetClauseCount = *otapic::OTAPI_Wrap_Hook_GetClauseCount;
*Hook_GetClauseAtIndex = *otapic::OTAPI_Wrap_Hook_GetClauseAtIndex;
*Bylaw_GetCallbackCount = *otapic::OTAPI_Wrap_Bylaw_GetCallbackCount;
*Callback_GetNameByIndex = *otapic::OTAPI_Wrap_Callback_GetNameByIndex;
*Callback_GetClause = *otapic::OTAPI_Wrap_Callback_GetClause;
*Smart_GetPartyCount = *otapic::OTAPI_Wrap_Smart_GetPartyCount;
*Smart_GetPartyByIndex = *otapic::OTAPI_Wrap_Smart_GetPartyByIndex;
*Smart_IsPartyConfirmed = *otapic::OTAPI_Wrap_Smart_IsPartyConfirmed;
*Party_GetID = *otapic::OTAPI_Wrap_Party_GetID;
*Party_GetAcctCount = *otapic::OTAPI_Wrap_Party_GetAcctCount;
*Party_GetAcctNameByIndex = *otapic::OTAPI_Wrap_Party_GetAcctNameByIndex;
*Party_GetAcctID = *otapic::OTAPI_Wrap_Party_GetAcctID;
*Party_GetAcctAssetID = *otapic::OTAPI_Wrap_Party_GetAcctAssetID;
*Party_GetAcctAgentName = *otapic::OTAPI_Wrap_Party_GetAcctAgentName;
*Party_GetAgentCount = *otapic::OTAPI_Wrap_Party_GetAgentCount;
*Party_GetAgentNameByIndex = *otapic::OTAPI_Wrap_Party_GetAgentNameByIndex;
*Party_GetAgentID = *otapic::OTAPI_Wrap_Party_GetAgentID;
*activateSmartContract = *otapic::OTAPI_Wrap_activateSmartContract;
*triggerClause = *otapic::OTAPI_Wrap_triggerClause;
*Msg_HarvestTransactionNumbers = *otapic::OTAPI_Wrap_Msg_HarvestTransactionNumbers;
*LoadUserPubkey_Encryption = *otapic::OTAPI_Wrap_LoadUserPubkey_Encryption;
*LoadUserPubkey_Signing = *otapic::OTAPI_Wrap_LoadUserPubkey_Signing;
*LoadPubkey_Encryption = *otapic::OTAPI_Wrap_LoadPubkey_Encryption;
*LoadPubkey_Signing = *otapic::OTAPI_Wrap_LoadPubkey_Signing;
*VerifyUserPrivateKey = *otapic::OTAPI_Wrap_VerifyUserPrivateKey;
*LoadPurse = *otapic::OTAPI_Wrap_LoadPurse;
*LoadMint = *otapic::OTAPI_Wrap_LoadMint;
*LoadAssetContract = *otapic::OTAPI_Wrap_LoadAssetContract;
*LoadServerContract = *otapic::OTAPI_Wrap_LoadServerContract;
*Mint_IsStillGood = *otapic::OTAPI_Wrap_Mint_IsStillGood;
*IsBasketCurrency = *otapic::OTAPI_Wrap_IsBasketCurrency;
*Basket_GetMemberCount = *otapic::OTAPI_Wrap_Basket_GetMemberCount;
*Basket_GetMemberType = *otapic::OTAPI_Wrap_Basket_GetMemberType;
*Basket_GetMinimumTransferAmount = *otapic::OTAPI_Wrap_Basket_GetMinimumTransferAmount;
*Basket_GetMemberMinimumTransferAmount = *otapic::OTAPI_Wrap_Basket_GetMemberMinimumTransferAmount;
*LoadAssetAccount = *otapic::OTAPI_Wrap_LoadAssetAccount;
*LoadInbox = *otapic::OTAPI_Wrap_LoadInbox;
*LoadOutbox = *otapic::OTAPI_Wrap_LoadOutbox;
*LoadInboxNoVerify = *otapic::OTAPI_Wrap_LoadInboxNoVerify;
*LoadOutboxNoVerify = *otapic::OTAPI_Wrap_LoadOutboxNoVerify;
*LoadPaymentInbox = *otapic::OTAPI_Wrap_LoadPaymentInbox;
*LoadPaymentInboxNoVerify = *otapic::OTAPI_Wrap_LoadPaymentInboxNoVerify;
*LoadRecordBox = *otapic::OTAPI_Wrap_LoadRecordBox;
*LoadRecordBoxNoVerify = *otapic::OTAPI_Wrap_LoadRecordBoxNoVerify;
*ClearRecord = *otapic::OTAPI_Wrap_ClearRecord;
*LoadExpiredBox = *otapic::OTAPI_Wrap_LoadExpiredBox;
*LoadExpiredBoxNoVerify = *otapic::OTAPI_Wrap_LoadExpiredBoxNoVerify;
*ClearExpired = *otapic::OTAPI_Wrap_ClearExpired;
*Ledger_GetCount = *otapic::OTAPI_Wrap_Ledger_GetCount;
*Ledger_CreateResponse = *otapic::OTAPI_Wrap_Ledger_CreateResponse;
*Ledger_GetTransactionByIndex = *otapic::OTAPI_Wrap_Ledger_GetTransactionByIndex;
*Ledger_GetTransactionByID = *otapic::OTAPI_Wrap_Ledger_GetTransactionByID;
*Ledger_GetTransactionIDByIndex = *otapic::OTAPI_Wrap_Ledger_GetTransactionIDByIndex;
*Ledger_AddTransaction = *otapic::OTAPI_Wrap_Ledger_AddTransaction;
*Transaction_CreateResponse = *otapic::OTAPI_Wrap_Transaction_CreateResponse;
*Ledger_FinalizeResponse = *otapic::OTAPI_Wrap_Ledger_FinalizeResponse;
*Ledger_GetInstrument = *otapic::OTAPI_Wrap_Ledger_GetInstrument;
*RecordPayment = *otapic::OTAPI_Wrap_RecordPayment;
*Transaction_GetType = *otapic::OTAPI_Wrap_Transaction_GetType;
*ReplyNotice_GetRequestNum = *otapic::OTAPI_Wrap_ReplyNotice_GetRequestNum;
*Transaction_GetVoucher = *otapic::OTAPI_Wrap_Transaction_GetVoucher;
*Transaction_GetSuccess = *otapic::OTAPI_Wrap_Transaction_GetSuccess;
*Transaction_IsCanceled = *otapic::OTAPI_Wrap_Transaction_IsCanceled;
*Transaction_GetBalanceAgreementSuccess = *otapic::OTAPI_Wrap_Transaction_GetBalanceAgreementSuccess;
*Transaction_GetDateSigned = *otapic::OTAPI_Wrap_Transaction_GetDateSigned;
*Transaction_GetAmount = *otapic::OTAPI_Wrap_Transaction_GetAmount;
*Pending_GetNote = *otapic::OTAPI_Wrap_Pending_GetNote;
*Transaction_GetSenderUserID = *otapic::OTAPI_Wrap_Transaction_GetSenderUserID;
*Transaction_GetSenderAcctID = *otapic::OTAPI_Wrap_Transaction_GetSenderAcctID;
*Transaction_GetRecipientUserID = *otapic::OTAPI_Wrap_Transaction_GetRecipientUserID;
*Transaction_GetRecipientAcctID = *otapic::OTAPI_Wrap_Transaction_GetRecipientAcctID;
*Transaction_GetDisplayReferenceToNum = *otapic::OTAPI_Wrap_Transaction_GetDisplayReferenceToNum;
*SavePurse = *otapic::OTAPI_Wrap_SavePurse;
*CreatePurse = *otapic::OTAPI_Wrap_CreatePurse;
*CreatePurse_Passphrase = *otapic::OTAPI_Wrap_CreatePurse_Passphrase;
*Purse_GetTotalValue = *otapic::OTAPI_Wrap_Purse_GetTotalValue;
*Purse_Count = *otapic::OTAPI_Wrap_Purse_Count;
*Purse_HasPassword = *otapic::OTAPI_Wrap_Purse_HasPassword;
*Purse_Peek = *otapic::OTAPI_Wrap_Purse_Peek;
*Purse_Pop = *otapic::OTAPI_Wrap_Purse_Pop;
*Purse_Push = *otapic::OTAPI_Wrap_Purse_Push;
*Purse_Empty = *otapic::OTAPI_Wrap_Purse_Empty;
*Wallet_ImportPurse = *otapic::OTAPI_Wrap_Wallet_ImportPurse;
*exchangePurse = *otapic::OTAPI_Wrap_exchangePurse;
*Token_ChangeOwner = *otapic::OTAPI_Wrap_Token_ChangeOwner;
*Token_GetID = *otapic::OTAPI_Wrap_Token_GetID;
*Token_GetDenomination = *otapic::OTAPI_Wrap_Token_GetDenomination;
*Token_GetSeries = *otapic::OTAPI_Wrap_Token_GetSeries;
*Token_GetValidFrom = *otapic::OTAPI_Wrap_Token_GetValidFrom;
*Token_GetValidTo = *otapic::OTAPI_Wrap_Token_GetValidTo;
*Token_GetAssetID = *otapic::OTAPI_Wrap_Token_GetAssetID;
*Token_GetServerID = *otapic::OTAPI_Wrap_Token_GetServerID;
*Instrmnt_GetAmount = *otapic::OTAPI_Wrap_Instrmnt_GetAmount;
*Instrmnt_GetTransNum = *otapic::OTAPI_Wrap_Instrmnt_GetTransNum;
*Instrmnt_GetValidFrom = *otapic::OTAPI_Wrap_Instrmnt_GetValidFrom;
*Instrmnt_GetValidTo = *otapic::OTAPI_Wrap_Instrmnt_GetValidTo;
*Instrmnt_GetMemo = *otapic::OTAPI_Wrap_Instrmnt_GetMemo;
*Instrmnt_GetType = *otapic::OTAPI_Wrap_Instrmnt_GetType;
*Instrmnt_GetServerID = *otapic::OTAPI_Wrap_Instrmnt_GetServerID;
*Instrmnt_GetAssetID = *otapic::OTAPI_Wrap_Instrmnt_GetAssetID;
*Instrmnt_GetSenderUserID = *otapic::OTAPI_Wrap_Instrmnt_GetSenderUserID;
*Instrmnt_GetSenderAcctID = *otapic::OTAPI_Wrap_Instrmnt_GetSenderAcctID;
*Instrmnt_GetRemitterUserID = *otapic::OTAPI_Wrap_Instrmnt_GetRemitterUserID;
*Instrmnt_GetRemitterAcctID = *otapic::OTAPI_Wrap_Instrmnt_GetRemitterAcctID;
*Instrmnt_GetRecipientUserID = *otapic::OTAPI_Wrap_Instrmnt_GetRecipientUserID;
*Instrmnt_GetRecipientAcctID = *otapic::OTAPI_Wrap_Instrmnt_GetRecipientAcctID;
*checkServerID = *otapic::OTAPI_Wrap_checkServerID;
*createUserAccount = *otapic::OTAPI_Wrap_createUserAccount;
*deleteUserAccount = *otapic::OTAPI_Wrap_deleteUserAccount;
*deleteAssetAccount = *otapic::OTAPI_Wrap_deleteAssetAccount;
*usageCredits = *otapic::OTAPI_Wrap_usageCredits;
*Message_GetUsageCredits = *otapic::OTAPI_Wrap_Message_GetUsageCredits;
*checkUser = *otapic::OTAPI_Wrap_checkUser;
*sendUserMessage = *otapic::OTAPI_Wrap_sendUserMessage;
*sendUserInstrument = *otapic::OTAPI_Wrap_sendUserInstrument;
*getRequest = *otapic::OTAPI_Wrap_getRequest;
*getTransactionNumber = *otapic::OTAPI_Wrap_getTransactionNumber;
*issueAssetType = *otapic::OTAPI_Wrap_issueAssetType;
*getContract = *otapic::OTAPI_Wrap_getContract;
*getMint = *otapic::OTAPI_Wrap_getMint;
*createAssetAccount = *otapic::OTAPI_Wrap_createAssetAccount;
*getAccount = *otapic::OTAPI_Wrap_getAccount;
*getAccountFiles = *otapic::OTAPI_Wrap_getAccountFiles;
*GenerateBasketCreation = *otapic::OTAPI_Wrap_GenerateBasketCreation;
*AddBasketCreationItem = *otapic::OTAPI_Wrap_AddBasketCreationItem;
*issueBasket = *otapic::OTAPI_Wrap_issueBasket;
*GenerateBasketExchange = *otapic::OTAPI_Wrap_GenerateBasketExchange;
*AddBasketExchangeItem = *otapic::OTAPI_Wrap_AddBasketExchangeItem;
*exchangeBasket = *otapic::OTAPI_Wrap_exchangeBasket;
*notarizeWithdrawal = *otapic::OTAPI_Wrap_notarizeWithdrawal;
*notarizeDeposit = *otapic::OTAPI_Wrap_notarizeDeposit;
*notarizeTransfer = *otapic::OTAPI_Wrap_notarizeTransfer;
*getInbox = *otapic::OTAPI_Wrap_getInbox;
*getOutbox = *otapic::OTAPI_Wrap_getOutbox;
*getNymbox = *otapic::OTAPI_Wrap_getNymbox;
*LoadNymbox = *otapic::OTAPI_Wrap_LoadNymbox;
*LoadNymboxNoVerify = *otapic::OTAPI_Wrap_LoadNymboxNoVerify;
*Nymbox_GetReplyNotice = *otapic::OTAPI_Wrap_Nymbox_GetReplyNotice;
*HaveAlreadySeenReply = *otapic::OTAPI_Wrap_HaveAlreadySeenReply;
*getBoxReceipt = *otapic::OTAPI_Wrap_getBoxReceipt;
*DoesBoxReceiptExist = *otapic::OTAPI_Wrap_DoesBoxReceiptExist;
*processInbox = *otapic::OTAPI_Wrap_processInbox;
*processNymbox = *otapic::OTAPI_Wrap_processNymbox;
*withdrawVoucher = *otapic::OTAPI_Wrap_withdrawVoucher;
*payDividend = *otapic::OTAPI_Wrap_payDividend;
*depositCheque = *otapic::OTAPI_Wrap_depositCheque;
*depositPaymentPlan = *otapic::OTAPI_Wrap_depositPaymentPlan;
*issueMarketOffer = *otapic::OTAPI_Wrap_issueMarketOffer;
*getMarketList = *otapic::OTAPI_Wrap_getMarketList;
*getMarketOffers = *otapic::OTAPI_Wrap_getMarketOffers;
*getMarketRecentTrades = *otapic::OTAPI_Wrap_getMarketRecentTrades;
*getNym_MarketOffers = *otapic::OTAPI_Wrap_getNym_MarketOffers;
*killMarketOffer = *otapic::OTAPI_Wrap_killMarketOffer;
*killPaymentPlan = *otapic::OTAPI_Wrap_killPaymentPlan;
*PopMessageBuffer = *otapic::OTAPI_Wrap_PopMessageBuffer;
*FlushMessageBuffer = *otapic::OTAPI_Wrap_FlushMessageBuffer;
*GetSentMessage = *otapic::OTAPI_Wrap_GetSentMessage;
*RemoveSentMessage = *otapic::OTAPI_Wrap_RemoveSentMessage;
*FlushSentMessages = *otapic::OTAPI_Wrap_FlushSentMessages;
*Sleep = *otapic::OTAPI_Wrap_Sleep;
*ResyncNymWithServer = *otapic::OTAPI_Wrap_ResyncNymWithServer;
*Message_GetCommand = *otapic::OTAPI_Wrap_Message_GetCommand;
*Message_GetSuccess = *otapic::OTAPI_Wrap_Message_GetSuccess;
*queryAssetTypes = *otapic::OTAPI_Wrap_queryAssetTypes;
*Message_GetPayload = *otapic::OTAPI_Wrap_Message_GetPayload;
*Message_GetDepth = *otapic::OTAPI_Wrap_Message_GetDepth;
*Message_GetTransactionSuccess = *otapic::OTAPI_Wrap_Message_GetTransactionSuccess;
*Message_IsTransactionCanceled = *otapic::OTAPI_Wrap_Message_IsTransactionCanceled;
*Message_GetBalanceAgreementSuccess = *otapic::OTAPI_Wrap_Message_GetBalanceAgreementSuccess;
*Message_GetLedger = *otapic::OTAPI_Wrap_Message_GetLedger;
*Message_GetNewAssetTypeID = *otapic::OTAPI_Wrap_Message_GetNewAssetTypeID;
*Message_GetNewIssuerAcctID = *otapic::OTAPI_Wrap_Message_GetNewIssuerAcctID;
*Message_GetNewAcctID = *otapic::OTAPI_Wrap_Message_GetNewAcctID;
*Message_GetNymboxHash = *otapic::OTAPI_Wrap_Message_GetNymboxHash;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OT_ME ##############

package otapi::OT_ME;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = otapic::new_OT_ME(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OT_ME($self);
        delete $OWNER{$self};
    }
}

*opentxs_copy_variables = *otapic::OT_ME_opentxs_copy_variables;
*opentxs_main_loop = *otapic::OT_ME_opentxs_main_loop;
*VerifyMessageSuccess = *otapic::OT_ME_VerifyMessageSuccess;
*VerifyMsgBalanceAgrmntSuccess = *otapic::OT_ME_VerifyMsgBalanceAgrmntSuccess;
*VerifyMsgTrnxSuccess = *otapic::OT_ME_VerifyMsgTrnxSuccess;
*InterpretTransactionMsgReply = *otapic::OT_ME_InterpretTransactionMsgReply;
*ExecuteScript_ReturnString = *otapic::OT_ME_ExecuteScript_ReturnString;
*ExecuteScript_ReturnBool = *otapic::OT_ME_ExecuteScript_ReturnBool;
*ExecuteScript_ReturnInt = *otapic::OT_ME_ExecuteScript_ReturnInt;
*ExecuteScript_ReturnVoid = *otapic::OT_ME_ExecuteScript_ReturnVoid;
*AddVariable = *otapic::OT_ME_AddVariable;
*FindVariable = *otapic::OT_ME_FindVariable;
*FindVariable2 = *otapic::OT_ME_FindVariable2;
*make_sure_enough_trans_nums = *otapic::OT_ME_make_sure_enough_trans_nums;
*register_nym = *otapic::OT_ME_register_nym;
*check_user = *otapic::OT_ME_check_user;
*create_pseudonym = *otapic::OT_ME_create_pseudonym;
*issue_asset_type = *otapic::OT_ME_issue_asset_type;
*issue_basket_currency = *otapic::OT_ME_issue_basket_currency;
*exchange_basket_currency = *otapic::OT_ME_exchange_basket_currency;
*retrieve_contract = *otapic::OT_ME_retrieve_contract;
*load_or_retrieve_contract = *otapic::OT_ME_load_or_retrieve_contract;
*create_asset_acct = *otapic::OT_ME_create_asset_acct;
*stat_asset_account = *otapic::OT_ME_stat_asset_account;
*retrieve_account = *otapic::OT_ME_retrieve_account;
*retrieve_nym = *otapic::OT_ME_retrieve_nym;
*send_transfer = *otapic::OT_ME_send_transfer;
*process_inbox = *otapic::OT_ME_process_inbox;
*accept_inbox_items = *otapic::OT_ME_accept_inbox_items;
*discard_incoming_payments = *otapic::OT_ME_discard_incoming_payments;
*cancel_outgoing_payments = *otapic::OT_ME_cancel_outgoing_payments;
*accept_from_paymentbox = *otapic::OT_ME_accept_from_paymentbox;
*load_public_encryption_key = *otapic::OT_ME_load_public_encryption_key;
*load_public_signing_key = *otapic::OT_ME_load_public_signing_key;
*load_or_retrieve_encrypt_key = *otapic::OT_ME_load_or_retrieve_encrypt_key;
*load_or_retrieve_signing_key = *otapic::OT_ME_load_or_retrieve_signing_key;
*send_user_msg_pubkey = *otapic::OT_ME_send_user_msg_pubkey;
*send_user_pmnt_pubkey = *otapic::OT_ME_send_user_pmnt_pubkey;
*send_user_cash_pubkey = *otapic::OT_ME_send_user_cash_pubkey;
*send_user_msg = *otapic::OT_ME_send_user_msg;
*send_user_payment = *otapic::OT_ME_send_user_payment;
*send_user_cash = *otapic::OT_ME_send_user_cash;
*withdraw_and_send_cash = *otapic::OT_ME_withdraw_and_send_cash;
*get_payment_instrument = *otapic::OT_ME_get_payment_instrument;
*get_box_receipt = *otapic::OT_ME_get_box_receipt;
*retrieve_mint = *otapic::OT_ME_retrieve_mint;
*load_or_retrieve_mint = *otapic::OT_ME_load_or_retrieve_mint;
*query_asset_types = *otapic::OT_ME_query_asset_types;
*create_market_offer = *otapic::OT_ME_create_market_offer;
*kill_market_offer = *otapic::OT_ME_kill_market_offer;
*kill_payment_plan = *otapic::OT_ME_kill_payment_plan;
*cancel_payment_plan = *otapic::OT_ME_cancel_payment_plan;
*activate_smart_contract = *otapic::OT_ME_activate_smart_contract;
*trigger_clause = *otapic::OT_ME_trigger_clause;
*withdraw_cash = *otapic::OT_ME_withdraw_cash;
*easy_withdraw_cash = *otapic::OT_ME_easy_withdraw_cash;
*export_cash = *otapic::OT_ME_export_cash;
*withdraw_voucher = *otapic::OT_ME_withdraw_voucher;
*pay_dividend = *otapic::OT_ME_pay_dividend;
*deposit_cheque = *otapic::OT_ME_deposit_cheque;
*deposit_cash = *otapic::OT_ME_deposit_cash;
*deposit_local_purse = *otapic::OT_ME_deposit_local_purse;
*get_market_list = *otapic::OT_ME_get_market_list;
*get_market_offers = *otapic::OT_ME_get_market_offers;
*get_nym_market_offers = *otapic::OT_ME_get_nym_market_offers;
*get_market_recent_trades = *otapic::OT_ME_get_market_recent_trades;
*adjust_usage_credits = *otapic::OT_ME_adjust_usage_credits;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Storable ##############

package otapi::Storable;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Storable($self);
        delete $OWNER{$self};
    }
}

*Create = *otapic::Storable_Create;
*ot_dynamic_cast = *otapic::Storable_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Storage ##############

package otapi::Storage;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
*GetPacker = *otapic::Storage_GetPacker;
*Exists = *otapic::Storage_Exists;
*FormPathString = *otapic::Storage_FormPathString;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Storage($self);
        delete $OWNER{$self};
    }
}

*StoreString = *otapic::Storage_StoreString;
*QueryString = *otapic::Storage_QueryString;
*StorePlainString = *otapic::Storage_StorePlainString;
*QueryPlainString = *otapic::Storage_QueryPlainString;
*StoreObject = *otapic::Storage_StoreObject;
*QueryObject = *otapic::Storage_QueryObject;
*EncodeObject = *otapic::Storage_EncodeObject;
*DecodeObject = *otapic::Storage_DecodeObject;
*EraseValueByKey = *otapic::Storage_EraseValueByKey;
*CreateObject = *otapic::Storage_CreateObject;
*Create = *otapic::Storage_Create;
*GetType = *otapic::Storage_GetType;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OTDBString ##############

package otapi::OTDBString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OTDBString($self);
        delete $OWNER{$self};
    }
}

*swig_m_string_get = *otapic::OTDBString_m_string_get;
*swig_m_string_set = *otapic::OTDBString_m_string_set;
*ot_dynamic_cast = *otapic::OTDBString_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Blob ##############

package otapi::Blob;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Blob($self);
        delete $OWNER{$self};
    }
}

*swig_m_memBuffer_get = *otapic::Blob_m_memBuffer_get;
*swig_m_memBuffer_set = *otapic::Blob_m_memBuffer_set;
*ot_dynamic_cast = *otapic::Blob_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::StringMap ##############

package otapi::StringMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_StringMap($self);
        delete $OWNER{$self};
    }
}

*swig_the_map_get = *otapic::StringMap_the_map_get;
*swig_the_map_set = *otapic::StringMap_the_map_set;
*SetValue = *otapic::StringMap_SetValue;
*GetValue = *otapic::StringMap_GetValue;
*ot_dynamic_cast = *otapic::StringMap_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Displayable ##############

package otapi::Displayable;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Displayable($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::Displayable_gui_label_get;
*swig_gui_label_set = *otapic::Displayable_gui_label_set;
*ot_dynamic_cast = *otapic::Displayable_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::MarketData ##############

package otapi::MarketData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_MarketData($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::MarketData_gui_label_get;
*swig_gui_label_set = *otapic::MarketData_gui_label_set;
*swig_server_id_get = *otapic::MarketData_server_id_get;
*swig_server_id_set = *otapic::MarketData_server_id_set;
*swig_market_id_get = *otapic::MarketData_market_id_get;
*swig_market_id_set = *otapic::MarketData_market_id_set;
*swig_asset_type_id_get = *otapic::MarketData_asset_type_id_get;
*swig_asset_type_id_set = *otapic::MarketData_asset_type_id_set;
*swig_currency_type_id_get = *otapic::MarketData_currency_type_id_get;
*swig_currency_type_id_set = *otapic::MarketData_currency_type_id_set;
*swig_scale_get = *otapic::MarketData_scale_get;
*swig_scale_set = *otapic::MarketData_scale_set;
*swig_total_assets_get = *otapic::MarketData_total_assets_get;
*swig_total_assets_set = *otapic::MarketData_total_assets_set;
*swig_number_bids_get = *otapic::MarketData_number_bids_get;
*swig_number_bids_set = *otapic::MarketData_number_bids_set;
*swig_number_asks_get = *otapic::MarketData_number_asks_get;
*swig_number_asks_set = *otapic::MarketData_number_asks_set;
*swig_last_sale_price_get = *otapic::MarketData_last_sale_price_get;
*swig_last_sale_price_set = *otapic::MarketData_last_sale_price_set;
*swig_current_bid_get = *otapic::MarketData_current_bid_get;
*swig_current_bid_set = *otapic::MarketData_current_bid_set;
*swig_current_ask_get = *otapic::MarketData_current_ask_get;
*swig_current_ask_set = *otapic::MarketData_current_ask_set;
*swig_volume_trades_get = *otapic::MarketData_volume_trades_get;
*swig_volume_trades_set = *otapic::MarketData_volume_trades_set;
*swig_volume_assets_get = *otapic::MarketData_volume_assets_get;
*swig_volume_assets_set = *otapic::MarketData_volume_assets_set;
*swig_volume_currency_get = *otapic::MarketData_volume_currency_get;
*swig_volume_currency_set = *otapic::MarketData_volume_currency_set;
*swig_recent_highest_bid_get = *otapic::MarketData_recent_highest_bid_get;
*swig_recent_highest_bid_set = *otapic::MarketData_recent_highest_bid_set;
*swig_recent_lowest_ask_get = *otapic::MarketData_recent_lowest_ask_get;
*swig_recent_lowest_ask_set = *otapic::MarketData_recent_lowest_ask_set;
*swig_last_sale_date_get = *otapic::MarketData_last_sale_date_get;
*swig_last_sale_date_set = *otapic::MarketData_last_sale_date_set;
*ot_dynamic_cast = *otapic::MarketData_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::MarketList ##############

package otapi::MarketList;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_MarketList($self);
        delete $OWNER{$self};
    }
}

*GetMarketDataCount = *otapic::MarketList_GetMarketDataCount;
*GetMarketData = *otapic::MarketList_GetMarketData;
*RemoveMarketData = *otapic::MarketList_RemoveMarketData;
*AddMarketData = *otapic::MarketList_AddMarketData;
*ot_dynamic_cast = *otapic::MarketList_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OfferDataMarket ##############

package otapi::OfferDataMarket;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OfferDataMarket($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::OfferDataMarket_gui_label_get;
*swig_gui_label_set = *otapic::OfferDataMarket_gui_label_set;
*swig_transaction_id_get = *otapic::OfferDataMarket_transaction_id_get;
*swig_transaction_id_set = *otapic::OfferDataMarket_transaction_id_set;
*swig_price_per_scale_get = *otapic::OfferDataMarket_price_per_scale_get;
*swig_price_per_scale_set = *otapic::OfferDataMarket_price_per_scale_set;
*swig_available_assets_get = *otapic::OfferDataMarket_available_assets_get;
*swig_available_assets_set = *otapic::OfferDataMarket_available_assets_set;
*swig_minimum_increment_get = *otapic::OfferDataMarket_minimum_increment_get;
*swig_minimum_increment_set = *otapic::OfferDataMarket_minimum_increment_set;
*swig_date_get = *otapic::OfferDataMarket_date_get;
*swig_date_set = *otapic::OfferDataMarket_date_set;
*ot_dynamic_cast = *otapic::OfferDataMarket_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::BidData ##############

package otapi::BidData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::OfferDataMarket otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_BidData($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::BidData_gui_label_get;
*swig_gui_label_set = *otapic::BidData_gui_label_set;
*swig_transaction_id_get = *otapic::BidData_transaction_id_get;
*swig_transaction_id_set = *otapic::BidData_transaction_id_set;
*swig_price_per_scale_get = *otapic::BidData_price_per_scale_get;
*swig_price_per_scale_set = *otapic::BidData_price_per_scale_set;
*swig_available_assets_get = *otapic::BidData_available_assets_get;
*swig_available_assets_set = *otapic::BidData_available_assets_set;
*swig_minimum_increment_get = *otapic::BidData_minimum_increment_get;
*swig_minimum_increment_set = *otapic::BidData_minimum_increment_set;
*swig_date_get = *otapic::BidData_date_get;
*swig_date_set = *otapic::BidData_date_set;
*ot_dynamic_cast = *otapic::BidData_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::AskData ##############

package otapi::AskData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::OfferDataMarket otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_AskData($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::AskData_gui_label_get;
*swig_gui_label_set = *otapic::AskData_gui_label_set;
*swig_transaction_id_get = *otapic::AskData_transaction_id_get;
*swig_transaction_id_set = *otapic::AskData_transaction_id_set;
*swig_price_per_scale_get = *otapic::AskData_price_per_scale_get;
*swig_price_per_scale_set = *otapic::AskData_price_per_scale_set;
*swig_available_assets_get = *otapic::AskData_available_assets_get;
*swig_available_assets_set = *otapic::AskData_available_assets_set;
*swig_minimum_increment_get = *otapic::AskData_minimum_increment_get;
*swig_minimum_increment_set = *otapic::AskData_minimum_increment_set;
*swig_date_get = *otapic::AskData_date_get;
*swig_date_set = *otapic::AskData_date_set;
*ot_dynamic_cast = *otapic::AskData_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OfferListMarket ##############

package otapi::OfferListMarket;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OfferListMarket($self);
        delete $OWNER{$self};
    }
}

*GetBidDataCount = *otapic::OfferListMarket_GetBidDataCount;
*GetBidData = *otapic::OfferListMarket_GetBidData;
*RemoveBidData = *otapic::OfferListMarket_RemoveBidData;
*AddBidData = *otapic::OfferListMarket_AddBidData;
*GetAskDataCount = *otapic::OfferListMarket_GetAskDataCount;
*GetAskData = *otapic::OfferListMarket_GetAskData;
*RemoveAskData = *otapic::OfferListMarket_RemoveAskData;
*AddAskData = *otapic::OfferListMarket_AddAskData;
*ot_dynamic_cast = *otapic::OfferListMarket_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::TradeDataMarket ##############

package otapi::TradeDataMarket;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_TradeDataMarket($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::TradeDataMarket_gui_label_get;
*swig_gui_label_set = *otapic::TradeDataMarket_gui_label_set;
*swig_transaction_id_get = *otapic::TradeDataMarket_transaction_id_get;
*swig_transaction_id_set = *otapic::TradeDataMarket_transaction_id_set;
*swig_date_get = *otapic::TradeDataMarket_date_get;
*swig_date_set = *otapic::TradeDataMarket_date_set;
*swig_price_get = *otapic::TradeDataMarket_price_get;
*swig_price_set = *otapic::TradeDataMarket_price_set;
*swig_amount_sold_get = *otapic::TradeDataMarket_amount_sold_get;
*swig_amount_sold_set = *otapic::TradeDataMarket_amount_sold_set;
*ot_dynamic_cast = *otapic::TradeDataMarket_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::TradeListMarket ##############

package otapi::TradeListMarket;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_TradeListMarket($self);
        delete $OWNER{$self};
    }
}

*GetTradeDataMarketCount = *otapic::TradeListMarket_GetTradeDataMarketCount;
*GetTradeDataMarket = *otapic::TradeListMarket_GetTradeDataMarket;
*RemoveTradeDataMarket = *otapic::TradeListMarket_RemoveTradeDataMarket;
*AddTradeDataMarket = *otapic::TradeListMarket_AddTradeDataMarket;
*ot_dynamic_cast = *otapic::TradeListMarket_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OfferDataNym ##############

package otapi::OfferDataNym;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OfferDataNym($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::OfferDataNym_gui_label_get;
*swig_gui_label_set = *otapic::OfferDataNym_gui_label_set;
*swig_valid_from_get = *otapic::OfferDataNym_valid_from_get;
*swig_valid_from_set = *otapic::OfferDataNym_valid_from_set;
*swig_valid_to_get = *otapic::OfferDataNym_valid_to_get;
*swig_valid_to_set = *otapic::OfferDataNym_valid_to_set;
*swig_server_id_get = *otapic::OfferDataNym_server_id_get;
*swig_server_id_set = *otapic::OfferDataNym_server_id_set;
*swig_asset_type_id_get = *otapic::OfferDataNym_asset_type_id_get;
*swig_asset_type_id_set = *otapic::OfferDataNym_asset_type_id_set;
*swig_asset_acct_id_get = *otapic::OfferDataNym_asset_acct_id_get;
*swig_asset_acct_id_set = *otapic::OfferDataNym_asset_acct_id_set;
*swig_currency_type_id_get = *otapic::OfferDataNym_currency_type_id_get;
*swig_currency_type_id_set = *otapic::OfferDataNym_currency_type_id_set;
*swig_currency_acct_id_get = *otapic::OfferDataNym_currency_acct_id_get;
*swig_currency_acct_id_set = *otapic::OfferDataNym_currency_acct_id_set;
*swig_selling_get = *otapic::OfferDataNym_selling_get;
*swig_selling_set = *otapic::OfferDataNym_selling_set;
*swig_scale_get = *otapic::OfferDataNym_scale_get;
*swig_scale_set = *otapic::OfferDataNym_scale_set;
*swig_price_per_scale_get = *otapic::OfferDataNym_price_per_scale_get;
*swig_price_per_scale_set = *otapic::OfferDataNym_price_per_scale_set;
*swig_transaction_id_get = *otapic::OfferDataNym_transaction_id_get;
*swig_transaction_id_set = *otapic::OfferDataNym_transaction_id_set;
*swig_total_assets_get = *otapic::OfferDataNym_total_assets_get;
*swig_total_assets_set = *otapic::OfferDataNym_total_assets_set;
*swig_finished_so_far_get = *otapic::OfferDataNym_finished_so_far_get;
*swig_finished_so_far_set = *otapic::OfferDataNym_finished_so_far_set;
*swig_minimum_increment_get = *otapic::OfferDataNym_minimum_increment_get;
*swig_minimum_increment_set = *otapic::OfferDataNym_minimum_increment_set;
*swig_stop_sign_get = *otapic::OfferDataNym_stop_sign_get;
*swig_stop_sign_set = *otapic::OfferDataNym_stop_sign_set;
*swig_stop_price_get = *otapic::OfferDataNym_stop_price_get;
*swig_stop_price_set = *otapic::OfferDataNym_stop_price_set;
*swig_date_get = *otapic::OfferDataNym_date_get;
*swig_date_set = *otapic::OfferDataNym_date_set;
*ot_dynamic_cast = *otapic::OfferDataNym_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OfferListNym ##############

package otapi::OfferListNym;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OfferListNym($self);
        delete $OWNER{$self};
    }
}

*GetOfferDataNymCount = *otapic::OfferListNym_GetOfferDataNymCount;
*GetOfferDataNym = *otapic::OfferListNym_GetOfferDataNym;
*RemoveOfferDataNym = *otapic::OfferListNym_RemoveOfferDataNym;
*AddOfferDataNym = *otapic::OfferListNym_AddOfferDataNym;
*ot_dynamic_cast = *otapic::OfferListNym_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::TradeDataNym ##############

package otapi::TradeDataNym;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_TradeDataNym($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::TradeDataNym_gui_label_get;
*swig_gui_label_set = *otapic::TradeDataNym_gui_label_set;
*swig_transaction_id_get = *otapic::TradeDataNym_transaction_id_get;
*swig_transaction_id_set = *otapic::TradeDataNym_transaction_id_set;
*swig_completed_count_get = *otapic::TradeDataNym_completed_count_get;
*swig_completed_count_set = *otapic::TradeDataNym_completed_count_set;
*swig_date_get = *otapic::TradeDataNym_date_get;
*swig_date_set = *otapic::TradeDataNym_date_set;
*swig_price_get = *otapic::TradeDataNym_price_get;
*swig_price_set = *otapic::TradeDataNym_price_set;
*swig_amount_sold_get = *otapic::TradeDataNym_amount_sold_get;
*swig_amount_sold_set = *otapic::TradeDataNym_amount_sold_set;
*swig_updated_id_get = *otapic::TradeDataNym_updated_id_get;
*swig_updated_id_set = *otapic::TradeDataNym_updated_id_set;
*swig_offer_price_get = *otapic::TradeDataNym_offer_price_get;
*swig_offer_price_set = *otapic::TradeDataNym_offer_price_set;
*swig_finished_so_far_get = *otapic::TradeDataNym_finished_so_far_get;
*swig_finished_so_far_set = *otapic::TradeDataNym_finished_so_far_set;
*swig_asset_id_get = *otapic::TradeDataNym_asset_id_get;
*swig_asset_id_set = *otapic::TradeDataNym_asset_id_set;
*swig_currency_id_get = *otapic::TradeDataNym_currency_id_get;
*swig_currency_id_set = *otapic::TradeDataNym_currency_id_set;
*swig_currency_paid_get = *otapic::TradeDataNym_currency_paid_get;
*swig_currency_paid_set = *otapic::TradeDataNym_currency_paid_set;
*ot_dynamic_cast = *otapic::TradeDataNym_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::TradeListNym ##############

package otapi::TradeListNym;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_TradeListNym($self);
        delete $OWNER{$self};
    }
}

*GetTradeDataNymCount = *otapic::TradeListNym_GetTradeDataNymCount;
*GetTradeDataNym = *otapic::TradeListNym_GetTradeDataNym;
*RemoveTradeDataNym = *otapic::TradeListNym_RemoveTradeDataNym;
*AddTradeDataNym = *otapic::TradeListNym_AddTradeDataNym;
*ot_dynamic_cast = *otapic::TradeListNym_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Acct ##############

package otapi::Acct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Acct($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::Acct_gui_label_get;
*swig_gui_label_set = *otapic::Acct_gui_label_set;
*swig_acct_id_get = *otapic::Acct_acct_id_get;
*swig_acct_id_set = *otapic::Acct_acct_id_set;
*swig_server_id_get = *otapic::Acct_server_id_get;
*swig_server_id_set = *otapic::Acct_server_id_set;
*ot_dynamic_cast = *otapic::Acct_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::BitcoinAcct ##############

package otapi::BitcoinAcct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Acct otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_BitcoinAcct($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::BitcoinAcct_gui_label_get;
*swig_gui_label_set = *otapic::BitcoinAcct_gui_label_set;
*swig_acct_id_get = *otapic::BitcoinAcct_acct_id_get;
*swig_acct_id_set = *otapic::BitcoinAcct_acct_id_set;
*swig_server_id_get = *otapic::BitcoinAcct_server_id_get;
*swig_server_id_set = *otapic::BitcoinAcct_server_id_set;
*swig_bitcoin_acct_name_get = *otapic::BitcoinAcct_bitcoin_acct_name_get;
*swig_bitcoin_acct_name_set = *otapic::BitcoinAcct_bitcoin_acct_name_set;
*ot_dynamic_cast = *otapic::BitcoinAcct_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::ServerInfo ##############

package otapi::ServerInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_ServerInfo($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::ServerInfo_gui_label_get;
*swig_gui_label_set = *otapic::ServerInfo_gui_label_set;
*swig_server_id_get = *otapic::ServerInfo_server_id_get;
*swig_server_id_set = *otapic::ServerInfo_server_id_set;
*swig_server_type_get = *otapic::ServerInfo_server_type_get;
*swig_server_type_set = *otapic::ServerInfo_server_type_set;
*ot_dynamic_cast = *otapic::ServerInfo_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Server ##############

package otapi::Server;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::ServerInfo otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Server($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::Server_gui_label_get;
*swig_gui_label_set = *otapic::Server_gui_label_set;
*swig_server_id_get = *otapic::Server_server_id_get;
*swig_server_id_set = *otapic::Server_server_id_set;
*swig_server_type_get = *otapic::Server_server_type_get;
*swig_server_type_set = *otapic::Server_server_type_set;
*swig_server_host_get = *otapic::Server_server_host_get;
*swig_server_host_set = *otapic::Server_server_host_set;
*swig_server_port_get = *otapic::Server_server_port_get;
*swig_server_port_set = *otapic::Server_server_port_set;
*ot_dynamic_cast = *otapic::Server_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::BitcoinServer ##############

package otapi::BitcoinServer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Server otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_BitcoinServer($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::BitcoinServer_gui_label_get;
*swig_gui_label_set = *otapic::BitcoinServer_gui_label_set;
*swig_server_id_get = *otapic::BitcoinServer_server_id_get;
*swig_server_id_set = *otapic::BitcoinServer_server_id_set;
*swig_server_type_get = *otapic::BitcoinServer_server_type_get;
*swig_server_type_set = *otapic::BitcoinServer_server_type_set;
*swig_server_host_get = *otapic::BitcoinServer_server_host_get;
*swig_server_host_set = *otapic::BitcoinServer_server_host_set;
*swig_server_port_get = *otapic::BitcoinServer_server_port_get;
*swig_server_port_set = *otapic::BitcoinServer_server_port_set;
*swig_bitcoin_username_get = *otapic::BitcoinServer_bitcoin_username_get;
*swig_bitcoin_username_set = *otapic::BitcoinServer_bitcoin_username_set;
*swig_bitcoin_password_get = *otapic::BitcoinServer_bitcoin_password_get;
*swig_bitcoin_password_set = *otapic::BitcoinServer_bitcoin_password_set;
*ot_dynamic_cast = *otapic::BitcoinServer_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::RippleServer ##############

package otapi::RippleServer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Server otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_RippleServer($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::RippleServer_gui_label_get;
*swig_gui_label_set = *otapic::RippleServer_gui_label_set;
*swig_server_id_get = *otapic::RippleServer_server_id_get;
*swig_server_id_set = *otapic::RippleServer_server_id_set;
*swig_server_type_get = *otapic::RippleServer_server_type_get;
*swig_server_type_set = *otapic::RippleServer_server_type_set;
*swig_server_host_get = *otapic::RippleServer_server_host_get;
*swig_server_host_set = *otapic::RippleServer_server_host_set;
*swig_server_port_get = *otapic::RippleServer_server_port_get;
*swig_server_port_set = *otapic::RippleServer_server_port_set;
*swig_ripple_username_get = *otapic::RippleServer_ripple_username_get;
*swig_ripple_username_set = *otapic::RippleServer_ripple_username_set;
*swig_ripple_password_get = *otapic::RippleServer_ripple_password_get;
*swig_ripple_password_set = *otapic::RippleServer_ripple_password_set;
*swig_namefield_id_get = *otapic::RippleServer_namefield_id_get;
*swig_namefield_id_set = *otapic::RippleServer_namefield_id_set;
*swig_passfield_id_get = *otapic::RippleServer_passfield_id_get;
*swig_passfield_id_set = *otapic::RippleServer_passfield_id_set;
*ot_dynamic_cast = *otapic::RippleServer_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::LoomServer ##############

package otapi::LoomServer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Server otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_LoomServer($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::LoomServer_gui_label_get;
*swig_gui_label_set = *otapic::LoomServer_gui_label_set;
*swig_server_id_get = *otapic::LoomServer_server_id_get;
*swig_server_id_set = *otapic::LoomServer_server_id_set;
*swig_server_type_get = *otapic::LoomServer_server_type_get;
*swig_server_type_set = *otapic::LoomServer_server_type_set;
*swig_server_host_get = *otapic::LoomServer_server_host_get;
*swig_server_host_set = *otapic::LoomServer_server_host_set;
*swig_server_port_get = *otapic::LoomServer_server_port_get;
*swig_server_port_set = *otapic::LoomServer_server_port_set;
*swig_loom_username_get = *otapic::LoomServer_loom_username_get;
*swig_loom_username_set = *otapic::LoomServer_loom_username_set;
*swig_namefield_id_get = *otapic::LoomServer_namefield_id_get;
*swig_namefield_id_set = *otapic::LoomServer_namefield_id_set;
*ot_dynamic_cast = *otapic::LoomServer_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::ContactNym ##############

package otapi::ContactNym;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_ContactNym($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::ContactNym_gui_label_get;
*swig_gui_label_set = *otapic::ContactNym_gui_label_set;
*swig_nym_type_get = *otapic::ContactNym_nym_type_get;
*swig_nym_type_set = *otapic::ContactNym_nym_type_set;
*swig_nym_id_get = *otapic::ContactNym_nym_id_get;
*swig_nym_id_set = *otapic::ContactNym_nym_id_set;
*swig_public_key_get = *otapic::ContactNym_public_key_get;
*swig_public_key_set = *otapic::ContactNym_public_key_set;
*swig_memo_get = *otapic::ContactNym_memo_get;
*swig_memo_set = *otapic::ContactNym_memo_set;
*GetServerInfoCount = *otapic::ContactNym_GetServerInfoCount;
*GetServerInfo = *otapic::ContactNym_GetServerInfo;
*RemoveServerInfo = *otapic::ContactNym_RemoveServerInfo;
*AddServerInfo = *otapic::ContactNym_AddServerInfo;
*ot_dynamic_cast = *otapic::ContactNym_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::WalletData ##############

package otapi::WalletData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_WalletData($self);
        delete $OWNER{$self};
    }
}

*GetBitcoinServerCount = *otapic::WalletData_GetBitcoinServerCount;
*GetBitcoinServer = *otapic::WalletData_GetBitcoinServer;
*RemoveBitcoinServer = *otapic::WalletData_RemoveBitcoinServer;
*AddBitcoinServer = *otapic::WalletData_AddBitcoinServer;
*GetBitcoinAcctCount = *otapic::WalletData_GetBitcoinAcctCount;
*GetBitcoinAcct = *otapic::WalletData_GetBitcoinAcct;
*RemoveBitcoinAcct = *otapic::WalletData_RemoveBitcoinAcct;
*AddBitcoinAcct = *otapic::WalletData_AddBitcoinAcct;
*GetRippleServerCount = *otapic::WalletData_GetRippleServerCount;
*GetRippleServer = *otapic::WalletData_GetRippleServer;
*RemoveRippleServer = *otapic::WalletData_RemoveRippleServer;
*AddRippleServer = *otapic::WalletData_AddRippleServer;
*GetLoomServerCount = *otapic::WalletData_GetLoomServerCount;
*GetLoomServer = *otapic::WalletData_GetLoomServer;
*RemoveLoomServer = *otapic::WalletData_RemoveLoomServer;
*AddLoomServer = *otapic::WalletData_AddLoomServer;
*ot_dynamic_cast = *otapic::WalletData_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::ContactAcct ##############

package otapi::ContactAcct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_ContactAcct($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::ContactAcct_gui_label_get;
*swig_gui_label_set = *otapic::ContactAcct_gui_label_set;
*swig_server_type_get = *otapic::ContactAcct_server_type_get;
*swig_server_type_set = *otapic::ContactAcct_server_type_set;
*swig_server_id_get = *otapic::ContactAcct_server_id_get;
*swig_server_id_set = *otapic::ContactAcct_server_id_set;
*swig_asset_type_id_get = *otapic::ContactAcct_asset_type_id_get;
*swig_asset_type_id_set = *otapic::ContactAcct_asset_type_id_set;
*swig_acct_id_get = *otapic::ContactAcct_acct_id_get;
*swig_acct_id_set = *otapic::ContactAcct_acct_id_set;
*swig_nym_id_get = *otapic::ContactAcct_nym_id_get;
*swig_nym_id_set = *otapic::ContactAcct_nym_id_set;
*swig_memo_get = *otapic::ContactAcct_memo_get;
*swig_memo_set = *otapic::ContactAcct_memo_set;
*swig_public_key_get = *otapic::ContactAcct_public_key_get;
*swig_public_key_set = *otapic::ContactAcct_public_key_set;
*ot_dynamic_cast = *otapic::ContactAcct_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::Contact ##############

package otapi::Contact;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Displayable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_Contact($self);
        delete $OWNER{$self};
    }
}

*swig_gui_label_get = *otapic::Contact_gui_label_get;
*swig_gui_label_set = *otapic::Contact_gui_label_set;
*swig_contact_id_get = *otapic::Contact_contact_id_get;
*swig_contact_id_set = *otapic::Contact_contact_id_set;
*swig_email_get = *otapic::Contact_email_get;
*swig_email_set = *otapic::Contact_email_set;
*swig_memo_get = *otapic::Contact_memo_get;
*swig_memo_set = *otapic::Contact_memo_set;
*swig_public_key_get = *otapic::Contact_public_key_get;
*swig_public_key_set = *otapic::Contact_public_key_set;
*GetContactNymCount = *otapic::Contact_GetContactNymCount;
*GetContactNym = *otapic::Contact_GetContactNym;
*RemoveContactNym = *otapic::Contact_RemoveContactNym;
*AddContactNym = *otapic::Contact_AddContactNym;
*GetContactAcctCount = *otapic::Contact_GetContactAcctCount;
*GetContactAcct = *otapic::Contact_GetContactAcct;
*RemoveContactAcct = *otapic::Contact_RemoveContactAcct;
*AddContactAcct = *otapic::Contact_AddContactAcct;
*ot_dynamic_cast = *otapic::Contact_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::AddressBook ##############

package otapi::AddressBook;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi::Storable otapi );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_AddressBook($self);
        delete $OWNER{$self};
    }
}

*GetContactCount = *otapic::AddressBook_GetContactCount;
*GetContact = *otapic::AddressBook_GetContact;
*RemoveContact = *otapic::AddressBook_RemoveContact;
*AddContact = *otapic::AddressBook_AddContact;
*ot_dynamic_cast = *otapic::AddressBook_ot_dynamic_cast;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OTRecord ##############

package otapi::OTRecord;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
*Mail = *otapic::OTRecord_Mail;
*Transfer = *otapic::OTRecord_Transfer;
*Receipt = *otapic::OTRecord_Receipt;
*Instrument = *otapic::OTRecord_Instrument;
*ErrorState = *otapic::OTRecord_ErrorState;
*SetSpecialMail = *otapic::OTRecord_SetSpecialMail;
*IsSpecialMail = *otapic::OTRecord_IsSpecialMail;
*IsPending = *otapic::OTRecord_IsPending;
*IsOutgoing = *otapic::OTRecord_IsOutgoing;
*IsRecord = *otapic::OTRecord_IsRecord;
*IsReceipt = *otapic::OTRecord_IsReceipt;
*IsMail = *otapic::OTRecord_IsMail;
*IsTransfer = *otapic::OTRecord_IsTransfer;
*IsCheque = *otapic::OTRecord_IsCheque;
*IsInvoice = *otapic::OTRecord_IsInvoice;
*IsVoucher = *otapic::OTRecord_IsVoucher;
*IsContract = *otapic::OTRecord_IsContract;
*IsPaymentPlan = *otapic::OTRecord_IsPaymentPlan;
*IsCash = *otapic::OTRecord_IsCash;
*HasContents = *otapic::OTRecord_HasContents;
*HasMemo = *otapic::OTRecord_HasMemo;
*IsExpired = *otapic::OTRecord_IsExpired;
*IsCanceled = *otapic::OTRecord_IsCanceled;
*SetExpired = *otapic::OTRecord_SetExpired;
*SetCanceled = *otapic::OTRecord_SetCanceled;
*GetValidFrom = *otapic::OTRecord_GetValidFrom;
*GetValidTo = *otapic::OTRecord_GetValidTo;
*SetDateRange = *otapic::OTRecord_SetDateRange;
*CanDeleteRecord = *otapic::OTRecord_CanDeleteRecord;
*CanAcceptIncoming = *otapic::OTRecord_CanAcceptIncoming;
*CanDiscardIncoming = *otapic::OTRecord_CanDiscardIncoming;
*CanCancelOutgoing = *otapic::OTRecord_CanCancelOutgoing;
*CanDiscardOutgoingCash = *otapic::OTRecord_CanDiscardOutgoingCash;
*CancelOutgoing = *otapic::OTRecord_CancelOutgoing;
*AcceptIncomingInstrument = *otapic::OTRecord_AcceptIncomingInstrument;
*AcceptIncomingTransfer = *otapic::OTRecord_AcceptIncomingTransfer;
*AcceptIncomingReceipt = *otapic::OTRecord_AcceptIncomingReceipt;
*DiscardIncoming = *otapic::OTRecord_DiscardIncoming;
*DeleteRecord = *otapic::OTRecord_DeleteRecord;
*DiscardOutgoingCash = *otapic::OTRecord_DiscardOutgoingCash;
*GetBoxIndex = *otapic::OTRecord_GetBoxIndex;
*SetBoxIndex = *otapic::OTRecord_SetBoxIndex;
*GetMethodID = *otapic::OTRecord_GetMethodID;
*SetMethodID = *otapic::OTRecord_SetMethodID;
*GetMsgID = *otapic::OTRecord_GetMsgID;
*SetMsgID = *otapic::OTRecord_SetMsgID;
*GetMsgType = *otapic::OTRecord_GetMsgType;
*SetMsgType = *otapic::OTRecord_SetMsgType;
*GetMsgTypeDisplay = *otapic::OTRecord_GetMsgTypeDisplay;
*SetMsgTypeDisplay = *otapic::OTRecord_SetMsgTypeDisplay;
*GetTransactionNum = *otapic::OTRecord_GetTransactionNum;
*SetTransactionNum = *otapic::OTRecord_SetTransactionNum;
*GetTransNumForDisplay = *otapic::OTRecord_GetTransNumForDisplay;
*SetTransNumForDisplay = *otapic::OTRecord_SetTransNumForDisplay;
*GetRecordType = *otapic::OTRecord_GetRecordType;
*GetServerID = *otapic::OTRecord_GetServerID;
*GetAssetID = *otapic::OTRecord_GetAssetID;
*GetCurrencyTLA = *otapic::OTRecord_GetCurrencyTLA;
*GetNymID = *otapic::OTRecord_GetNymID;
*GetAccountID = *otapic::OTRecord_GetAccountID;
*GetAddress = *otapic::OTRecord_GetAddress;
*GetOtherNymID = *otapic::OTRecord_GetOtherNymID;
*GetOtherAccountID = *otapic::OTRecord_GetOtherAccountID;
*GetOtherAddress = *otapic::OTRecord_GetOtherAddress;
*GetName = *otapic::OTRecord_GetName;
*GetDate = *otapic::OTRecord_GetDate;
*GetAmount = *otapic::OTRecord_GetAmount;
*GetInstrumentType = *otapic::OTRecord_GetInstrumentType;
*GetMemo = *otapic::OTRecord_GetMemo;
*GetContents = *otapic::OTRecord_GetContents;
*SetOtherNymID = *otapic::OTRecord_SetOtherNymID;
*SetOtherAccountID = *otapic::OTRecord_SetOtherAccountID;
*SetAddress = *otapic::OTRecord_SetAddress;
*SetOtherAddress = *otapic::OTRecord_SetOtherAddress;
*SetMemo = *otapic::OTRecord_SetMemo;
*SetContents = *otapic::OTRecord_SetContents;
*HasInitialPayment = *otapic::OTRecord_HasInitialPayment;
*HasPaymentPlan = *otapic::OTRecord_HasPaymentPlan;
*GetInitialPaymentDate = *otapic::OTRecord_GetInitialPaymentDate;
*GetPaymentPlanStartDate = *otapic::OTRecord_GetPaymentPlanStartDate;
*GetTimeBetweenPayments = *otapic::OTRecord_GetTimeBetweenPayments;
*GetInitialPaymentAmount = *otapic::OTRecord_GetInitialPaymentAmount;
*GetPaymentPlanAmount = *otapic::OTRecord_GetPaymentPlanAmount;
*GetMaximumNoPayments = *otapic::OTRecord_GetMaximumNoPayments;
*FormatAmount = *otapic::OTRecord_FormatAmount;
*FormatDescription = *otapic::OTRecord_FormatDescription;
*FormatShortMailDescription = *otapic::OTRecord_FormatShortMailDescription;
*FormatMailSubject = *otapic::OTRecord_FormatMailSubject;
sub new {
    my $pkg = shift;
    my $self = otapic::new_OTRecord(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OTRecord($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OTNameLookup ##############

package otapi::OTNameLookup;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = $_[0];
    my $self = otapic::new_OTNameLookup(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OTNameLookup($self);
        delete $OWNER{$self};
    }
}

*GetNymName = *otapic::OTNameLookup_GetNymName;
*GetAcctName = *otapic::OTNameLookup_GetAcctName;
*GetAddressName = *otapic::OTNameLookup_GetAddressName;
sub DISOWN {
    my $self = shift;
    otapic::disown_OTNameLookup($self);
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    if (not $self->can($member_func)) {
        my $h = otapic::swig_get_attr_OTNameLookup($self);
        return $h->{$field} if $h;
    }
    return $self->$member_func;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    if (not $self->can($member_func)) {
        my $h = otapic::swig_get_attr_OTNameLookup($self);
        return $h->{$field} = $newval if $h;
    }
    return $self->$member_func($newval);
}

############# Class : otapi::OTLookupCaller ##############

package otapi::OTLookupCaller;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = otapic::new_OTLookupCaller(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OTLookupCaller($self);
        delete $OWNER{$self};
    }
}

*getCallback = *otapic::OTLookupCaller_getCallback;
*delCallback = *otapic::OTLookupCaller_delCallback;
*setCallback = *otapic::OTLookupCaller_setCallback;
*isCallbackSet = *otapic::OTLookupCaller_isCallbackSet;
*GetNymName = *otapic::OTLookupCaller_GetNymName;
*GetAcctName = *otapic::OTLookupCaller_GetAcctName;
*GetAddressName = *otapic::OTLookupCaller_GetAddressName;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : otapi::OTRecordList ##############

package otapi::OTRecordList;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( otapi );
%OWNER = ();
%ITERATORS = ();
*setAddrBookCaller = *otapic::OTRecordList_setAddrBookCaller;
*getAddrBookCaller = *otapic::OTRecordList_getAddrBookCaller;
sub new {
    my $pkg = shift;
    my $self = otapic::new_OTRecordList(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        otapic::delete_OTRecordList($self);
        delete $OWNER{$self};
    }
}

*textTo = *otapic::OTRecordList_textTo;
*textFrom = *otapic::OTRecordList_textFrom;
*setTextTo = *otapic::OTRecordList_setTextTo;
*setTextFrom = *otapic::OTRecordList_setTextFrom;
*SetFastMode = *otapic::OTRecordList_SetFastMode;
*SetServerID = *otapic::OTRecordList_SetServerID;
*AddServerID = *otapic::OTRecordList_AddServerID;
*ClearServers = *otapic::OTRecordList_ClearServers;
*SetAssetID = *otapic::OTRecordList_SetAssetID;
*AddAssetID = *otapic::OTRecordList_AddAssetID;
*ClearAssets = *otapic::OTRecordList_ClearAssets;
*SetNymID = *otapic::OTRecordList_SetNymID;
*AddNymID = *otapic::OTRecordList_AddNymID;
*ClearNyms = *otapic::OTRecordList_ClearNyms;
*SetAccountID = *otapic::OTRecordList_SetAccountID;
*AddAccountID = *otapic::OTRecordList_AddAccountID;
*ClearAccounts = *otapic::OTRecordList_ClearAccounts;
*GetNyms = *otapic::OTRecordList_GetNyms;
*AcceptChequesAutomatically = *otapic::OTRecordList_AcceptChequesAutomatically;
*AcceptReceiptsAutomatically = *otapic::OTRecordList_AcceptReceiptsAutomatically;
*AcceptTransfersAutomatically = *otapic::OTRecordList_AcceptTransfersAutomatically;
*AcceptCashAutomatically = *otapic::OTRecordList_AcceptCashAutomatically;
*DoesAcceptChequesAutomatically = *otapic::OTRecordList_DoesAcceptChequesAutomatically;
*DoesAcceptReceiptsAutomatically = *otapic::OTRecordList_DoesAcceptReceiptsAutomatically;
*DoesAcceptTransfersAutomatically = *otapic::OTRecordList_DoesAcceptTransfersAutomatically;
*DoesAcceptCashAutomatically = *otapic::OTRecordList_DoesAcceptCashAutomatically;
*PerformAutoAccept = *otapic::OTRecordList_PerformAutoAccept;
*Populate = *otapic::OTRecordList_Populate;
*ClearContents = *otapic::OTRecordList_ClearContents;
*SortRecords = *otapic::OTRecordList_SortRecords;
*AddSpecialMsg = *otapic::OTRecordList_AddSpecialMsg;
*size = *otapic::OTRecordList_size;
*GetRecord = *otapic::OTRecordList_GetRecord;
*RemoveRecord = *otapic::OTRecordList_RemoveRecord;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package otapi;

*OT_PW_DISPLAY = *otapic::OT_PW_DISPLAY;
*OTPASSWORD_BLOCKSIZE = *otapic::OTPASSWORD_BLOCKSIZE;
*OTPASSWORD_MEMSIZE = *otapic::OTPASSWORD_MEMSIZE;
*OT_LARGE_BLOCKSIZE = *otapic::OT_LARGE_BLOCKSIZE;
*OT_LARGE_MEMSIZE = *otapic::OT_LARGE_MEMSIZE;
*OT_DEFAULT_BLOCKSIZE = *otapic::OT_DEFAULT_BLOCKSIZE;
*OT_DEFAULT_MEMSIZE = *otapic::OT_DEFAULT_MEMSIZE;
*PACK_MESSAGE_PACK = *otapic::PACK_MESSAGE_PACK;
*PACK_PROTOCOL_BUFFERS = *otapic::PACK_PROTOCOL_BUFFERS;
*PACK_TYPE_ERROR = *otapic::PACK_TYPE_ERROR;
*STORE_FILESYSTEM = *otapic::STORE_FILESYSTEM;
*STORE_TYPE_SUBCLASS = *otapic::STORE_TYPE_SUBCLASS;
*STORED_OBJ_STRING = *otapic::STORED_OBJ_STRING;
*STORED_OBJ_BLOB = *otapic::STORED_OBJ_BLOB;
*STORED_OBJ_STRING_MAP = *otapic::STORED_OBJ_STRING_MAP;
*STORED_OBJ_WALLET_DATA = *otapic::STORED_OBJ_WALLET_DATA;
*STORED_OBJ_BITCOIN_ACCT = *otapic::STORED_OBJ_BITCOIN_ACCT;
*STORED_OBJ_BITCOIN_SERVER = *otapic::STORED_OBJ_BITCOIN_SERVER;
*STORED_OBJ_RIPPLE_SERVER = *otapic::STORED_OBJ_RIPPLE_SERVER;
*STORED_OBJ_LOOM_SERVER = *otapic::STORED_OBJ_LOOM_SERVER;
*STORED_OBJ_SERVER_INFO = *otapic::STORED_OBJ_SERVER_INFO;
*STORED_OBJ_CONTACT_NYM = *otapic::STORED_OBJ_CONTACT_NYM;
*STORED_OBJ_CONTACT_ACCT = *otapic::STORED_OBJ_CONTACT_ACCT;
*STORED_OBJ_CONTACT = *otapic::STORED_OBJ_CONTACT;
*STORED_OBJ_ADDRESS_BOOK = *otapic::STORED_OBJ_ADDRESS_BOOK;
*STORED_OBJ_MARKET_DATA = *otapic::STORED_OBJ_MARKET_DATA;
*STORED_OBJ_MARKET_LIST = *otapic::STORED_OBJ_MARKET_LIST;
*STORED_OBJ_BID_DATA = *otapic::STORED_OBJ_BID_DATA;
*STORED_OBJ_ASK_DATA = *otapic::STORED_OBJ_ASK_DATA;
*STORED_OBJ_OFFER_LIST_MARKET = *otapic::STORED_OBJ_OFFER_LIST_MARKET;
*STORED_OBJ_TRADE_DATA_MARKET = *otapic::STORED_OBJ_TRADE_DATA_MARKET;
*STORED_OBJ_TRADE_LIST_MARKET = *otapic::STORED_OBJ_TRADE_LIST_MARKET;
*STORED_OBJ_OFFER_DATA_NYM = *otapic::STORED_OBJ_OFFER_DATA_NYM;
*STORED_OBJ_OFFER_LIST_NYM = *otapic::STORED_OBJ_OFFER_LIST_NYM;
*STORED_OBJ_TRADE_DATA_NYM = *otapic::STORED_OBJ_TRADE_DATA_NYM;
*STORED_OBJ_TRADE_LIST_NYM = *otapic::STORED_OBJ_TRADE_LIST_NYM;
*STORED_OBJ_ERROR = *otapic::STORED_OBJ_ERROR;
1;
